package ritogaems.tov.gameEngine.Input;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Point;

import ritogaems.tov.gameEngine.entity.Direction;
import ritogaems.tov.gameEngine.graphics.HudObject;
import ritogaems.tov.util.BoundingBox;
import ritogaems.tov.util.Vector2;

/**
 * @author Kevin Martin - all except Andrews small part
 * @author Andrew Woods - direction method
 *         <p/>
 *         The joystick for player movement
 */
public class Joystick extends HudObject {

    /**
     * The center X position of the joystick
     */
    private float centerX;

    /**
     * The center Y position of the joystick
     */
    private float centerY;

    /**
     * The max distance the joystick can be moved from its center
     */
    private int maxBoundary;

    /**
     * Where on the joystick is currently being touched
     */
    private Point touchingPoint;

    /**
     * The angle at which
     */
    private double angle;

    /**
     * The bitmap representing the outer circle of the joystick
     */
    private Bitmap outerCircle;

    /**
     * The bitmap representing the inner circle of the joystick
     */
    private Bitmap innerCircle;

    /**
     * The vector generated by the joystick for the player to move by
     */
    private Vector2 vector = new Vector2();

    /**
     * The touch event currently being tracked
     */
    private TouchEvent event = new TouchEvent();

    /**
     * The last touch event being stored
     */
    private TouchEvent lastEvent;

    /**
     * Tracks if the user is currently dragging the joystick
     */
    private boolean dragging = false;

    /**
     * Stores the event ID to track
     */
    private int eventID = -1;

    /**
     * constructor for the joystick class
     *
     * @param xPos   x position on the screen
     * @param yPos   y position on the screen
     * @param width  the width of the bitmap
     * @param height the height of the bitmap
     * @param bitmap the bitmap used to represent this
     */
    public Joystick(float xPos, float yPos, int width, int height, Bitmap bitmap, Input input) {
        super(xPos, yPos, width, height, input);
        centerX = xPos;
        centerY = yPos;
        touchingPoint = new Point(Math.round(centerX), Math.round(centerY));
        maxBoundary = (int) ((width / 2) * 0.9f);
        innerCircle = Bitmap.createScaledBitmap(bitmap, (int) (width * 0.25f), (int) (height * 0.25f), false);
        outerCircle = Bitmap.createScaledBitmap(bitmap, width, height, false);
    }

    /**
     * Calculates where the joystick is currently being held for the player movement
     *
     * @return a vector for the player position to be updated by
     */
    public Vector2 calculate() {
        BoundingBox bound = getCollisionBox();

        if (eventID != -1) {
            if (!input.existsTouch(eventID)) {
                event.type = TouchEvent.TOUCH_UP;
                event.x = input.getTouchX(eventID);
                event.y = input.getTouchY(eventID);
                eventID = -1;
            } else {
                try {
                    event.x = input.getTouchX(eventID);
                    event.y = input.getTouchY(eventID);
                } catch (IndexOutOfBoundsException e) {
                    e.printStackTrace();
                }
            }
        } else {
            for (int i = 0; i < TouchHandler.MAX_TOUCH_POINTS; i++) {
                if (input.existsTouch(i)) {
                    if (bound.contains(input.getTouchX(i), input.getTouchY(i))) {
                        try {
                            eventID = i;
                            event.type = TouchEvent.TOUCH_DOWN;
                            event.x = input.getTouchX(eventID);
                            event.y = input.getTouchY(eventID);
                            i = TouchHandler.MAX_TOUCH_POINTS;
                        } catch (IndexOutOfBoundsException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

        // check the type of event entered and adjust the lastEvent
        if (event == null && lastEvent == null) {
            vector.set(0, 0);
        } else if (event == null && lastEvent != null) {
            event = lastEvent;
        } else {
            lastEvent = event;
        }

        updateJoystick();
        return vector;
    }

    /**
     * Update the joystick on screen and the current position being held
     */
    private void updateJoystick() {
        // set dragging to true/false if touch up/down
        if (event.type == TouchEvent.TOUCH_DOWN) {
            dragging = true;
        } else if (event.type == TouchEvent.TOUCH_UP) {
            dragging = false;
        }

        if (dragging) {
            if (event.x != touchingPoint.x && event.y != touchingPoint.y) {
                // if the joystick is moved away from the center calculate movement
                if (event.x > centerX + 5 || event.x < centerX - 5 || event.y > centerY + 5 || event.y < centerY - 5) {
                    // get the position of the touch event
                    touchingPoint.x = Math.round(event.x);
                    touchingPoint.y = Math.round(event.y);

                    // limit the joystick to its boundaries
                    if (touchingPoint.x < centerX - maxBoundary) {
                        touchingPoint.x = Math.round((centerX - maxBoundary));
                    }
                    if (touchingPoint.x > centerX + maxBoundary) {
                        touchingPoint.x = Math.round((centerX + maxBoundary));
                    }
                    if (touchingPoint.y < centerY - maxBoundary) {
                        touchingPoint.y = Math.round((centerY - maxBoundary));
                    }
                    if (touchingPoint.y > centerY + maxBoundary) {
                        touchingPoint.y = Math.round((centerY + maxBoundary));
                    }

                    // get the angle
                    angle = Math.atan2(touchingPoint.y - centerY, touchingPoint.x - centerX) / (Math.PI / 180);

                    // set the vector values in relation to the distance from the center
                    vector.x = (float) Math.cos(angle * (Math.PI / 180)) * (touchingPoint.y);
                    vector.y = (float) Math.sin(angle * (Math.PI / 180)) * (touchingPoint.y);
                } else {
                    touchingPoint.x = Math.round(centerX);
                    touchingPoint.y = Math.round(centerY);

                    vector.set(0, 0);
                }
            }
        } else {
            touchingPoint.x = Math.round(centerX);
            touchingPoint.y = Math.round(centerY);

            vector.set(0, 0);
        }
    }

    /**
     * Calculates the direction being moved in based on where the joystick is being held
     *
     * @return return a direction for choosing the correct player animation
     */
    public Direction checkDirection() {
        double angle = Math.atan2(touchingPoint.y - centerY, touchingPoint.x - centerX);

        double northEast = (-(Math.PI) / 4);
        double northWest = (-(3 * Math.PI) / 4);
        double southEast = ((Math.PI) / 4);
        double southWest = (4 * Math.PI) / 6;

        // check if its center
        if (touchingPoint.x < centerX + 5 && touchingPoint.x > centerX - 5 && touchingPoint.y < centerY + 5 && touchingPoint.y > centerY - 5) {
            return Direction.CENTER;
        } else if (angle < northEast && angle >= northWest) {
            return Direction.UP;
        } else if (angle < southWest && angle >= southEast) {
            return Direction.DOWN;
        } else if (angle < southEast && angle >= northEast) {
            return Direction.RIGHT;
        } else {
            return Direction.LEFT;
        }
    }

    /**
     * Draw the joystick to the HUD
     *
     * @param canvas The canvas to draw the Hud Object to
     */
    @Override
    public void drawHUD(Canvas canvas) {
        canvas.drawBitmap(outerCircle, centerX - (outerCircle.getWidth() / 2), centerY - (outerCircle.getHeight() / 2), null);
        canvas.drawBitmap(innerCircle, touchingPoint.x - (innerCircle.getWidth() / 2), touchingPoint.y - (innerCircle.getHeight() / 2), null);
    }
}